library ieee;
use ieee.std_logic_1164.all;
use ieee.std_logic_unsigned.all;

entity lcd is
	port (clk : in std_logic;
		rw,rs,en : out std_logic;
		d : out std_logic_vector (7 downto 0));
end lcd;

architecture behave of lcd is

--type dout is array (0 to 5) of std_logic_vector(7 downto 0);
--	constant a: dout:=(x"38",x"0C",x"06",x"01",x"02",x"80");
----constant a: dout:=("00000010", "00000001", "00011100", "00000011", "00110100", "00001110", "00000110", "10000000");
--	signal i,j :integer RANGE 0 TO 14:=0;
--type data is array (0 to 14) of std_logic_vector(7 downto 0);
--	constant b: data:=(x"49", x"4e", x"54", X"45", X"52", X"4C", x"4F", X"47", X"49", X"43", X"58", X"20", X"20", X"20", X"20");--INTERLOGICX
--	signal sig : std_logic_vector(23 downto 0):=(others=>'0');

type lookup is array(0 to 4) of std_logic_vector(7 downto 0);
signal lcdcmd : lookup:=(x"38",x"0E",x"06",x"01",x"80") ;


type datalookup is array(0 to 4) of  std_logic_vector(7 downto 0);
signal lcddata : datalookup:=(x"31",x"32",x"33",x"34",x"35") ;


signal countr : integer range 0 to 12000 :=0;
signal mystate : integer range 0 to 100 :=0;
signal LCDclk : std_logic:='0';
signal i : integer range 0 to 4 := 0;

begin

clkdiv: process(clk)
	begin
	
	if rising_edge(clk) then
	countr <= countr + 1;
	if (countr = 11999) then
	 LCDclk <= not( LCDclk);
	 countr <= 0;
	end if;

	end if;
end process;


lcdcontroller : process(lcdclk)
begin

if rising_edge(lcdclk) then

mystate <= mystate + 1;

case mystate is

when 4 => en <= '0' ;
when 5 => rs <= '0' ;
when 6 => rw <= '0' ;
when 7 => d <= lcdcmd(i) ;
when 8 => en <= '1' ;
when 9 => en <= '0' ;

if (i=4) then
i<=0;
else
i <= i+1;
mystate <= 4;
end if;

-------------------------- send data ----------------------
when 12 => rs <= '1' ;
when 13 => rw <= '0' ;
when 14 => d <= lcddata(i) ;
when 15 => en <= '1' ;
when 16 => en <= '0' ;

if (i=4) then
i<=0;
else
i <= i+1;
mystate <= 11;
end if;

when 18=>
mystate  <= 17;

--when 10 => rs <= '0' ;
--when 11 => rw <= '0' ;
--when 12 => d <= x"0E" ;
--when 13 => en <= '1' ;
--when 14 => en <= '0' ;
--
--when 15 => rs <= '0' ;
--when 16 => rw <= '0' ;
--when 17 => d <= x"06" ;
--when 18 => en <= '1' ;
--when 19 => en <= '0' ;
--
--when 20 => rs <= '0' ;
--when 21 => rw <= '0' ;
--when 22 => d <= x"01" ;
--when 23 => en <= '1' ;
--when 24 => en <= '0' ;
--
--when 25 => rs <= '0' ;
--when 26 => rw <= '0' ;
--when 27 => d <= x"80" ;
--when 28 => en <= '1' ;
--when 29 => en <= '0' ;
--
--







when others =>	

end case;



end if;

end process;


--	rw<='0';

--process(clk)
--begin
--
--if rising_edge(clk) then
--	sig<=sig+1;
--		case sig(23 downto 19) is
--			when "00000"=>rs<='0';
--			when "00001"=>d<=a(i);
--			when "00010"=>cs<='1';
--			when "00011"=>cs<='0';
--				i<=i+1;
--				if (i<5) then
--					sig(23 downto 19)<="00001";
--				else
--					sig(23 downto 19)<="00100";
--				end if;
--			when "00100"=>rs<='1';
--			when "00101"=>d<=b(j);
--			when "00110"=>cs<='1';
--			when "00111"=>cs<='0';
--				j<=j+1;
--				if (j<14) then
--					sig(23 downto 19)<="00101";
--				else
--					sig(23 downto 19)<="01000";
--				end if;
--			when "01000"=>
--				sig(23 downto 19)<="01000";
--			when others=>
--		end case;
--end if;
--end process;
end behave;
